## CPU 元件

- **程序计数器**：告诉 CPU 从哪里提取下一条指令， 指向**下一条指令的内存地址**
- **指令解码器**：解释指令，解释需要进行何种处理和涉及的内存单元
- **数据总线**：获取内存中的用于计算的数据
- **通用寄存器**：处理加减乘除比较等运算，暂存需要运算的数据
- **算术逻辑单元**：**实际执行指令的地方**，计算结果残存到寄存器或写回内存

## 寻址方式

汇编中, 内存地址引用的通用格式为: `起始地址或偏移(%基址寄存器, %索引寄存器, 比例因子)`.

寻址方式:

- 立即寻址：指令包含要访问的数据
  - `movl $1, %eax`
- 寄存器寻址：指令中包含要访问的寄存器，不是内存地址
  - `movl %eax, %ebx`
- 直接寻址：指令包含内存地址，可以直接读取地址获取数据
  - `movl ADDRESS, %ebx`
- 索引寻址: 通过指定索引寄存器和地址/偏移实现. 索引寄存器可以石任何通用寄存器
  - `起始地址(, %索引寄存器, 字长)`, 等同于 C 的`array[idx]`
- 变址寻址：内存地址 + 偏移量。 偏移量通过**变址寄存器**提供
- 间接寻址：指令中包含一个寄存器，寄存器中保存指针。需要访问指针获取数据的内存地址
  - `movl (%eax), %ebx`
- 基址寻址：间接寻址 + 偏移量
  - `movl 4(%ebp), %ebx`

## .data 数据段

### 数据类型

.data 段指定要使用的数据, 支持如下几种类型:

- `.byte`: 每个数字占用一个存储位置
- `.int`: 占用两个存储位置
- `.long`: 占用 4 个存储位置, 与寄存就使用空间相同
- `.ascii`: 用于 char 字符, 每个字符占用一个存储位置. 类似 C 的 char 数组

## .text 数据段

### 跳转语句

- `je`: 值相等则跳转
- `jg`: 第二个值大则跳转
- `jge`: 第二个值大于等于第一个值则跳转
- `jl`: 第二个值小则跳转
- `jle`: 第二个值小于等于第一个值则跳转
- `jmp`: 无条件跳转

### 函数与%esp

函数的调用需要**栈**，函数参数、局部变量、返回地址和返回值等都需要栈来保存。
栈操作的基本指令如下：

- `pushl`: 将寄存器值或内存之压入栈
- `popl`: 将栈顶的值从栈中取出
- **%esp 寄存器**: 指向当前栈顶的指针,会根据 push 或 pop 操作自动变更指向的位置
  - %esp 可以用于访问栈中元素(**间接寻址和基址寻址**)

需要调用函数时需要做如下操作:

- 使用 push 指令将函数的参数压入栈中
- 调用`call`指令调用函数. call 会做如下操作
  - 将 call 后面下一条指令的地址压入栈中, 即**返回地址**
  - **修改指令寄存器%eip**指向函数的起始位置
- 在函数内部需要注意以下操作
  - 进入函数第一条指令`pushl %ebp`保存进入函数之前的**基址指针寄存器%ebp**, 在函数退出时再恢复%ebp
  - 对%esp 执行`sub1`操作, 使栈往下移动,**留出空间保存函数内的局部变量**

函数栈的样子如下(32bit 系统为例):

```
参数 N <------N*4+4(%ebp)
...
参数 2 <---------12(%ebp)
参数 1 <----------8(%ebp)
返回地址 <---------4(%ebp)
 %ebp <------------(%ebp)
局部变量 1 <---- - -4(%ebp)
局部变量 2 <------ -8(%ebp), %esp栈顶
```

当函数执行完, 会做如下操作:

- 将返回值保存到%eax
- 移除当前栈, 使调用该函数的代码的栈帧重新生效
- 通过`ret`指令将控制器交给调用者, 并将返回地址弹出作为%eip 的值

ret 之后函数栈的样子(32bit 系统为例):

```
参数 N <----------N*4+4(%ebp)
...
参数 2 <----------12(%ebp)
参数 1 <----------8(%ebp)
```
